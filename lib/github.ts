import { Octokit } from "@octokit/rest";
import type { Incident } from "./agent";

const GITHUB_TOKEN = process.env.GITHUB_TOKEN;
const REPO_OWNER = process.env.GITHUB_REPO?.split("/")[0] || "Soulemane12";
const REPO_NAME = process.env.GITHUB_REPO?.split("/")[1] || "auto-ops-  -python";
const REPO_BRANCH = process.env.GITHUB_REPO_BRANCH || "master";

export async function createPullRequestForIncident(incident: Incident): Promise<string> {
  if (!GITHUB_TOKEN) {
    console.warn("GitHub token not found, simulating PR creation");
    return simulatePRCreation(incident);
  }

  try {
    const octokit = new Octokit({
      auth: GITHUB_TOKEN,
    });

    const branchName = `auto-ops-fix-incident-${incident.id.slice(0, 8)}`;

    // Step 1: Get the base branch SHA
    const mainBranch = await octokit.rest.repos.getBranch({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      branch: REPO_BRANCH
    });

    // Step 2: Create a new branch for the fix
    await octokit.rest.git.createRef({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      ref: `refs/heads/${branchName}`,
      sha: mainBranch.data.commit.sha,
    });

    console.log(`Created branch: ${branchName}`);

    const repoFilePath = getRepoRelativePath(incident.filename);

    // Step 3: Get current file content
    const currentFile = await octokit.rest.repos.getContent({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      path: repoFilePath,
      ref: branchName,
    });

    if (Array.isArray(currentFile.data) || currentFile.data.type !== "file") {
      throw new Error("Expected a single file");
    }

    // Step 4: Apply patch to create fixed content
    const originalContent = Buffer.from(currentFile.data.content, "base64").toString();
    const fixedContent = applyPatchToCode(originalContent, incident);

    // Step 5: Commit the fixed file
    const commitMessage = `Auto-ops fix: Resolve ${incident.error_type} in ${incident.filename}

Fixed by AUTO-OPS agent for incident ${incident.id}
- Error: ${incident.error_type}: ${incident.message}
- File: ${incident.filename}${incident.line ? `, Line: ${incident.line}` : ""}
- Tested in Daytona sandbox: ${incident.tests_passed ? "âœ… PASSED" : "âŒ FAILED"}

ðŸ¤– Generated by AUTO-OPS`;

    await octokit.rest.repos.createOrUpdateFileContents({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      path: repoFilePath,
      message: commitMessage,
      content: Buffer.from(fixedContent).toString("base64"),
      sha: currentFile.data.sha,
      branch: branchName,
    });

    console.log(`Committed fix to ${branchName}`);

    // Step 6: Create pull request
    const prTitle = `ðŸ”§ AUTO-OPS: Fix ${incident.error_type} in ${incident.filename}`;
    const prBody = generatePRBody(incident);

    const pullRequest = await octokit.rest.pulls.create({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      title: prTitle,
      head: branchName,
      base: REPO_BRANCH,
      body: prBody,
    });

    const prUrl = pullRequest.data.html_url;
    console.log(`âœ… Pull request created: ${prUrl}`);

    return prUrl;

  } catch (error) {
    console.error(`Error creating GitHub PR:`, error);
    // Return simulated PR for   
    return simulatePRCreation(incident);
  }
}

function applyPatchToCode(originalContent: string, incident: Incident): string {
  // For    purposes, apply a simple fix for KeyError
  if (incident.error_type === "KeyError" && incident.message.includes("customer")) {
    return originalContent.replace(
      'def checkout(order):',
      `def checkout(order):
    # AUTO-OPS Fix: Add validation to prevent KeyError
    if not order or not isinstance(order, dict):
        raise ValueError("Invalid order: must be a dictionary")
    if "customer" not in order:
        raise ValueError("Invalid order: missing customer information")`
    ).replace(
      'return order["customer"]["id"]  # will error if keys missing',
      `    if not isinstance(order["customer"], dict) or "id" not in order["customer"]:
        raise ValueError("Invalid customer: missing ID")
    return order["customer"]["id"]  # Fixed: added validation`
    );
  }

  // If no specific fix available, add basic error handling
  return `# AUTO-OPS Applied patch for ${incident.error_type}\n# Original error: ${incident.message}\n\n${originalContent}`;
}

function generatePRBody(incident: Incident): string {
  return `## ðŸ¤– AUTO-OPS Automated Fix

### Error Details
- **Error Type**: ${incident.error_type}
- **Message**: ${incident.message}
- **File**: ${incident.filename}${incident.line ? `
- **Line**: ${incident.line}` : ""}

### How Claude Fixed It
${incident.plan || "Applied automated error handling and validation"}

### Patch Applied
\`\`\`diff
${incident.patch || "Patch details not available"}
\`\`\`

### Testing Results
${incident.tests_passed ? "âœ…" : "âŒ"} **Tested in Daytona Sandbox**

\`\`\`
${incident.test_output || "Test output not available"}
\`\`\`

### CodeRabbit Review
This PR is automatically reviewed by CodeRabbit AI. Please check the review comments below.

---

ðŸ¤– **Generated by AUTO-OPS** | Incident ID: \`${incident.id}\`
ðŸ§ª **Tested in**: Daytona isolated environment
ðŸ” **AI Reviewed by**: CodeRabbit (auto-triggered)`;
}

function getRepoRelativePath(filename: string): string {
  if (!filename) {
    return filename;
  }

  const normalized = filename.replace(/\\/g, "/").replace(/^\/+/, "");
  const repoPrefix = `${REPO_NAME}/`;
  const repoIndex = normalized.indexOf(repoPrefix);

  if (repoIndex !== -1) {
    const relative = normalized.slice(repoIndex + repoPrefix.length);
    return relative.length > 0 ? relative : normalized.slice(normalized.lastIndexOf("/") + 1);
  }

  return normalized;
}

function simulatePRCreation(incident: Incident): string {
  const branchName = `auto-ops-fix-incident-${incident.id.slice(0, 8)}`;
  const simulatedPRUrl = `https://github.com/${REPO_OWNER}/${REPO_NAME}/pull/mock-pr-${incident.id.slice(0, 8)}`;

  console.log(`ðŸŽ­ Simulated GitHub PR creation:`);
  console.log(`Branch: ${branchName}`);
  console.log(`Title: ðŸ”§ AUTO-OPS: Fix ${incident.error_type} in ${incident.filename}`);
  console.log(`URL: ${simulatedPRUrl}`);
  console.log(`CodeRabbit will auto-review once PR is created`);

  return simulatedPRUrl;
}
